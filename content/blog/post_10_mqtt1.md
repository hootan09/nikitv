---
title: قسمت اول – مقدمه ای بر پروتکل MQTT در IOT و اینترنت اشیاء
image: images/post_10_mqtt/mqtt-tutorial-banner-mqtt-part-one-760x424-600x424.jpg
description: در این آموزش مطرح ترین پروتکلی که در اینترتت اشیاء استفاده میشود را بررسی خواهیم نمود. و سپس به در قسمت های آتی نحوه پیاده سازی آن و استفاده از آن در اینترنت اشیاء را به طور دقیق اعمال خواهیم کرد.این نکته حائز اهمیت است که آینده IOT به سمت استفاده از این پروتکل منتهی خواهد شد.
date: 2017-08-26T15:05:26+04:30
author: mam_niki
tags:
- iot
categories:
- برنامه نویسی
- نرم افزار
- سخت افزار
---

حدود سال 1999 بود که برای اولین بار پروتکلی به نام **MQTT** برای برقراری و استفاده در ارتباطات ماهواره ای نوشته شد . اون زمان کمتر کسی فکرشو میکرد که یه روزی این پروتکل برای IOT یا اصلاح فارسی غلطش (**اینترنت اشیاء**) مورد استفاده قرار بگیره .

این پروتکل شباهت های زیادی به websocket یا socketIO داره (از لحاظ فنی) اما برتری هاش واقعا قابل ملاحظه هستش.شاید بزرگترین مزیتش قابلیت رمزگذاری باشه.

توی این آموزش ما اول کمی این پروتکل رو معرفی میکنیم و اگه خسته نشید ، بیشتر راجع به بحث خود پروتکل می نویسم و در پایان (بخش های بعدی )یک پیاده سازی عادی توی ویندوز خواهیم داشت و میبینیم که چطور کار میکنه این پروتکل.

#### **MQTT چیست ؟**

{{< image src="images/post_10_mqtt/mqtt-tcp-ip-stack.png" caption="" command="fill" option="q95" class="img-fluid mx-auto d-block" title="" >}}

یک پروتکل استاندارد برمبنای publish/subscribe  هستش که به صورت پیام رد و بدل میشه.

این پروتکل با هدف ارتباط M2M یا ماشین با ماشین ساخته شده.اما **publish/subscribe** چیه؟

این publish/subscribe که اغلب به اختصار pub-sub خونده میشه در حقیقت قلب اصلی ارتباط کلاینت ها با هم هستش .یعنی یکی از کلاینت ها مثلا یه مطلب یا موضوعی رو publish  میکنه و بقیه کلاینت ها می تونند اونو subscribe کنند و پیامشو ببینند.

این پروتکل خیلی شبیه ارتباط کلاینت سرور هستش و به سرورش **broker** میگند

**(اما کلاینت/سرور نیست )**.و الباقی کلاینت ها یه توپولوژی ستاره ای شکل رو با سرور صورت میدند . یعنی سرور میشه قلب این پروتکل و کلاینت ها همه به اون وصل میشند.

{{< image src="images/post_10_mqtt/connect-flow.png" caption="" command="fill" option="q95" class="img-fluid mx-auto d-block" title="" >}}

طبق استاندارد این پروتکل کلاینت می تونه یه **topic**  یا موضوع رو publish یا subscribe کنه .کمی گنگه نه !!

بذارید یه مثال بزنم . فرض کنید ما می خوایم با سنسور دمای داخل آشپزخانه ی خونه رو بگیریم ، topic اون میشه

**‘sensors/temperature/home/kitchen’**  که ما با استفاده از ” / ” میتونیم یک ساختار درختی به اون topic یا موضوع بدیم .

یک مثال دیگه

فرض کنید ما میخوایم دمای هرجای دنیا رو هر یک دقیقه در میان بگیریم .برای این کار سنسور ها هر یک دقیقه یک بار یک عدد ازدمای خودشون رو به broker  میدند (publish) میکنند .و ما میتونیم با استفاده از broker دمای هرجایی که خواستیم رو بخونیم یا subscribe کنیم .  
**{sensors/temperature/{country}/{city}/{street name}**

حالا فرض کنید من میخوام مانگین دمای یک کشور رو بگیرم .در اون صورت می تونم از wildcards ها بهره بگیرم . بله این پروتکل از wildcards  های **+** و **\#** پشتیبانی میکنه

اگه بخوام تمام سنسور ها رو ببینم از + استفاده میکنم _sensors/+/uk/london/baker_street_.

(+ یعنی تمام topic های موجود )

اگه بخوام تمامی دماهای دنیا رو ببینم از # استفاده میکنم #/sensors/temperature/

(#  یعنی تمامی زیرشاخه های موجود)

{{< image src="images/post_10_mqtt/mqtt-article-buddhima.png" caption="" command="fill" option="q95" class="img-fluid mx-auto d-block" title="" >}}

این پروتکل همچنین دارای **QOS** نیز میباشد . (Quality of Service)

خب اینو بگم که qos دراین پروتکل سه حالت داره .

#### **QoS Level 0:**

ساده ترین حالت برقراری ارتباط با broker هست که نیازی به acknowledgment  نداره .

#### **QoS Level 1:**

در این حالت سرور مطمئن میشه که **حداقل** یک بار یا بیشتر بسته به کلاینت رسیده و ACK  از کلاینت میگیره.

#### **QoS Level 2:**

در این حالت broker یک و فقط یک بسته به کلاینت میفرسته و مطمئن میشه که بسته رسیده.این حالتش خیلی توصیه نمیشه .

همچنین این پروتکل حالاتی رو تشخیص میده که ارتباط قطع شده یا به هر دلیلی کلاینت نمیتونه با broker ارتباط برقرار کنه و در این حالت broker اقدام لازم رو انجام میده تا به خطا بر نخوریم. در همه این شرایط broker بقیه کلاینت ها رو هم با خبر میکنه.

### **Security**

کلاینت ها میتونند با فرستادن username  و password با broker ارتباط برقرار کنند .اما این یه مشکل امنیتی داره که هر بار توی همون بسته اطلاعات تصدیق هویتی رو بدون رمز گذاری میفرسته . البته خوشبختانه broker هایی هم هستند که قابلیت رمز گذاری TLS رو پشتیبانی میکنند .

#### **چند نمونه از نرم افزار های Broker**

تا کنون broker های متفاوتی برای این پروتکل نوشته شده که در زیر چند نمونه رو معرفی میکنیم .

* [Mosquitto](http://mosquitto.org/) اولین نسخه broker نوشته شده با زبان C و دارای تنظیمات مختلف.
* [Mosca](https://github.com/mcollina/mosca)  نوشته شده با Nodejs و بسیار محبوب ، سریع و قابل توسعه و با تنظیمات راحت.
* [RSMB](https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=d5bedadd-e46f-4c97-af89-22d65ffee070) نسخه نوشته شده توسط کمپانی IBM و کمتر محبوب اما با تنظیمات بسیار عالی ، پیاده سازی شده با زبان C
* [HiveMQ](http://www.hivemq.com/) این نسخه یک بازیگر جدیده که بسیار خوب ظاهر شده.گفته میشه که توی این نسخه قابلیت رمزگذاری TLS پشتیبانی میشه.

### **کتابخانه های کلاینت این زبان**

برای کلاینت این پروتکل میتونید به اینترنت مراجعه کنید .تقریبا برای اکثر زبان های برنامه نویسی نسخه کلاینت داره . زبان های C , java , python , javascript از پشتیبانی کننده های اون هستند . (به علت این که برای زبان های مختلف کلاینت داره محبوب IOT شده و در آینده نزیک توی قسمت های بعد اونو روی سخت افزار های اینترنت اشیاء پیاده خواهیم کرد. )

در پایان عکس زیر یک بسته که از کلاینت به سمت سرور میره رو خواهید دید که شامل چه اطلاعاتی هست.

{{< image src="images/post_10_mqtt/connect.png" caption="" command="fill" option="q95" class="img-fluid mx-auto d-block" title="" >}}

نکته مهم عکس بالا اینه که اگه پارامتر **cleanSession** برابر با **false** باشه .اون وقت سرور داده ها رو کش (cache) خواهد کرد و اگر کلاینتی دوباره متصل بشه .مقدار داده های قدیمی رو هم دریافت خواهد کرد.

عکس زیر هم جوابی هست که broker به کلاینت میده .

{{< image src="images/post_10_mqtt/connack1.png" caption="" command="fill" option="q95" class="img-fluid mx-auto d-block" title="" >}}

پایان قسمت اول.